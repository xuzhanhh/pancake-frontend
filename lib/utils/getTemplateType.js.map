{"version":3,"sources":["../../src/utils/getTemplateType.ts"],"names":["getTemplateTypeByTag","t","path","localName","has","tag","node","isCallExpression","isIdentifier","callee","arguments","length","name","tagPath","get","component","isMemberExpression","object","property","stringLiteral","cache","WeakMap","getTemplateType","types","state","libResolver","file","metadata","identifier","sources","scope","opts","filename","set"],"mappings":";;;;;;;AAQA;;;;AAQA,SAASA,oBAAT,CACEC,CADF,EAEEC,IAFF,EAGEC,SAHF,EAIEC,GAJF,EAKU;AACR,QAAM;AAAEC,IAAAA;AAAF,MAAUH,IAAI,CAACI,IAArB,CADQ,CAGR;;AACA,MACEL,CAAC,CAACM,gBAAF,CAAmBF,GAAnB,KACAJ,CAAC,CAACO,YAAF,CAAeH,GAAG,CAACI,MAAnB,CADA,IAEAJ,GAAG,CAACK,SAAJ,CAAcC,MAAd,KAAyB,CAFzB,IAGAN,GAAG,CAACI,MAAJ,CAAWG,IAAX,KAAoBT,SAHpB,IAIAC,GAAG,CAACD,SAAD,EAAY,CAAC,gBAAD,EAAmB,eAAnB,CAAZ,CALL,EAME;AACA,UAAMU,OAAO,GAAGX,IAAI,CAACY,GAAL,CAAS,KAAT,CAAhB;AACA,WAAO;AACLC,MAAAA,SAAS,EAAEF,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyB,CAAzB;AADN,KAAP;AAGD,GAfO,CAiBR;;;AACA,MACEb,CAAC,CAACe,kBAAF,CAAqBX,GAArB,KACAJ,CAAC,CAACO,YAAF,CAAeH,GAAG,CAACY,MAAnB,CADA,IAEAhB,CAAC,CAACO,YAAF,CAAeH,GAAG,CAACa,QAAnB,CAFA,IAGAb,GAAG,CAACY,MAAJ,CAAWL,IAAX,KAAoBT,SAHpB,IAIAC,GAAG,CAACD,SAAD,EAAY,CAAC,gBAAD,EAAmB,eAAnB,CAAZ,CALL,EAME;AACA,WAAO;AACLY,MAAAA,SAAS,EAAE;AAAET,QAAAA,IAAI,EAAEL,CAAC,CAACkB,aAAF,CAAgBd,GAAG,CAACa,QAAJ,CAAaN,IAA7B;AAAR;AADN,KAAP;AAGD,GA5BO,CA8BR;;;AACA,MACER,GAAG,CAAC,KAAD,EAAQ,CAAC,eAAD,EAAkB,SAAlB,CAAR,CAAH,IACAH,CAAC,CAACO,YAAF,CAAeH,GAAf,CADA,IAEAA,GAAG,CAACO,IAAJ,KAAa,KAHf,EAIE;AACA,WAAO,KAAP;AACD,GArCO,CAuCR;;;AACA,MACER,GAAG,CAAC,KAAD,EAAQ,CAAC,iBAAD,CAAR,CAAH,IACAH,CAAC,CAACO,YAAF,CAAeH,GAAf,CADA,IAEAA,GAAG,CAACO,IAAJ,KAAa,KAHf,EAIE;AACA,WAAO,YAAP;AACD;;AAED,SAAO,IAAP;AACD;;AAED,MAAMQ,KAAK,GAAG,IAAIC,OAAJ,EAAd;;AAEe,SAASC,eAAT,CACb;AAAEC,EAAAA,KAAK,EAAEtB;AAAT,CADa,EAEbC,IAFa,EAGbsB,KAHa,EAIbC,WAJa,EAKL;AAAA;;AACR,MAAI,CAACL,KAAK,CAAChB,GAAN,CAAUF,IAAV,CAAL,EAAsB;AACpB,UAAMC,SAAS,GAAGqB,KAAK,CAACE,IAAN,CAAWC,QAAX,CAAoBxB,SAApB,IAAiC,QAAnD;;AACA,UAAMC,GAAG,GAAG,CAACwB,UAAD,EAAqBC,OAArB,KACV,wBACE5B,CADF,EAEEC,IAAI,CAAC4B,KAFP,EAGEN,KAAK,CAACE,IAAN,CAAWK,IAAX,CAAgBC,QAHlB,EAIEJ,UAJF,EAKEC,OALF,EAMEJ,WANF,CADF;;AAUAL,IAAAA,KAAK,CAACa,GAAN,CAAU/B,IAAV,EAAgBF,oBAAoB,CAACC,CAAD,EAAIC,IAAJ,EAAUC,SAAV,EAAqBC,GAArB,CAApC;AACD;;AAED,uBAAOgB,KAAK,CAACN,GAAN,CAAUZ,IAAV,CAAP,mDAA0B,IAA1B;AACD","sourcesContent":["import type {\n  CallExpression,\n  Expression,\n  TaggedTemplateExpression,\n} from '@babel/types';\nimport type { NodePath } from '@babel/traverse';\nimport type { State, TemplateExpression, LibResolverFn } from '../types';\nimport { Core } from '../babel';\nimport hasImport from './hasImport';\n\ntype Result =\n  | NonNullable<TemplateExpression['styled']>\n  | 'css'\n  | 'atomic-css'\n  | null;\n\nfunction getTemplateTypeByTag(\n  t: Core['types'],\n  path: NodePath<TaggedTemplateExpression>,\n  localName: string,\n  has: (identifier: string, sources: string[]) => boolean\n): Result {\n  const { tag } = path.node;\n\n  // styled(Cmp)``\n  if (\n    t.isCallExpression(tag) &&\n    t.isIdentifier(tag.callee) &&\n    tag.arguments.length === 1 &&\n    tag.callee.name === localName &&\n    has(localName, ['@linaria/react', 'linaria/react'])\n  ) {\n    const tagPath = path.get('tag') as NodePath<CallExpression>;\n    return {\n      component: tagPath.get('arguments')[0] as NodePath<Expression>,\n    };\n  }\n\n  // styled.div``\n  if (\n    t.isMemberExpression(tag) &&\n    t.isIdentifier(tag.object) &&\n    t.isIdentifier(tag.property) &&\n    tag.object.name === localName &&\n    has(localName, ['@linaria/react', 'linaria/react'])\n  ) {\n    return {\n      component: { node: t.stringLiteral(tag.property.name) },\n    };\n  }\n\n  // css``\n  if (\n    has('css', ['@linaria/core', 'linaria']) &&\n    t.isIdentifier(tag) &&\n    tag.name === 'css'\n  ) {\n    return 'css';\n  }\n\n  // css`` but atomic\n  if (\n    has('css', ['@linaria/atomic']) &&\n    t.isIdentifier(tag) &&\n    tag.name === 'css'\n  ) {\n    return 'atomic-css';\n  }\n\n  return null;\n}\n\nconst cache = new WeakMap<NodePath<TaggedTemplateExpression>, Result>();\n\nexport default function getTemplateType(\n  { types: t }: Core,\n  path: NodePath<TaggedTemplateExpression>,\n  state: State,\n  libResolver?: LibResolverFn\n): Result {\n  if (!cache.has(path)) {\n    const localName = state.file.metadata.localName || 'styled';\n    const has = (identifier: string, sources: string[]) =>\n      hasImport(\n        t,\n        path.scope,\n        state.file.opts.filename,\n        identifier,\n        sources,\n        libResolver\n      );\n\n    cache.set(path, getTemplateTypeByTag(t, path, localName, has));\n  }\n\n  return cache.get(path) ?? null;\n}\n"],"file":"getTemplateType.js"}