{"version":3,"sources":["../../src/visitors/GenerateClassNames.ts"],"names":["GenerateClassNames","babel","path","state","options","libResolver","types","t","templateType","expressions","get","length","index","slug","displayName","predefinedClassName","parent","findParent","p","isObjectProperty","isJSXOpeningElement","isVariableDeclarator","parentNode","node","key","name","value","toString","keyPath","getSource","isJSXIdentifier","isIdentifier","id","file","opts","filename","test","replace","buildCodeFrameError","charAt","toLowerCase","root","process","cwd","slice","ext","slugVars","hash","title","dir","split","sep","pop","className","classNameSlug","Error","optionVariables","match","cnSlug","i","l","v","type","addComment"],"mappings":"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","sourcesContent":["/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it generates a slug that will be used as a CSS class for particular Template Expression,\n * and generates a display name for class or styled components.\n * It saves that meta data as comment above the template, to be later used in templateProcessor.\n */\n\nimport { basename, dirname, relative, extname, sep } from 'path';\nimport { slugify } from '@linaria/utils';\nimport type { ObjectProperty, TaggedTemplateExpression } from '@babel/types';\nimport type { NodePath } from '@babel/traverse';\nimport { debug } from '@linaria/logger';\nimport type { ClassNameSlugVars, State, StrictOptions } from '../types';\nimport toValidCSSIdentifier from '../utils/toValidCSSIdentifier';\nimport getLinariaComment from '../utils/getLinariaComment';\nimport getTemplateType from '../utils/getTemplateType';\nimport { Core } from '../babel';\nimport isSlugVar from '../utils/isSlugVar';\n\nexport default function GenerateClassNames(\n  babel: Core,\n  path: NodePath<TaggedTemplateExpression>,\n  state: State,\n  options: StrictOptions\n) {\n  const { libResolver } = options;\n  const { types: t } = babel;\n  const templateType = getTemplateType(babel, path, state, libResolver);\n  if (!templateType) {\n    return;\n  }\n\n  const expressions = path.get('quasi').get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  // Increment the index of the style we're processing\n  // This is used for slug generation to prevent collision\n  // Also used for display name if it couldn't be determined\n  state.index++;\n\n  let [, slug, displayName, predefinedClassName] = getLinariaComment(path);\n\n  const parent = path.findParent(\n    (p) =>\n      t.isObjectProperty(p) ||\n      t.isJSXOpeningElement(p) ||\n      t.isVariableDeclarator(p)\n  );\n\n  if (!displayName && parent) {\n    const parentNode = parent.node;\n    if (t.isObjectProperty(parentNode)) {\n      if ('name' in parentNode.key) {\n        displayName = parentNode.key.name;\n      } else if ('value' in parentNode.key) {\n        displayName = parentNode.key.value.toString();\n      } else {\n        const keyPath = (parent as NodePath<ObjectProperty>).get('key');\n        displayName = keyPath.getSource();\n      }\n    } else if (\n      t.isJSXOpeningElement(parentNode) &&\n      t.isJSXIdentifier(parentNode.name)\n    ) {\n      displayName = parentNode.name.name;\n    } else if (\n      t.isVariableDeclarator(parentNode) &&\n      t.isIdentifier(parentNode.id)\n    ) {\n      displayName = parentNode.id.name;\n    }\n  }\n\n  if (!displayName) {\n    // Try to derive the path from the filename\n    displayName = basename(state.file.opts.filename);\n\n    if (/^index\\.[a-z0-9]+$/.test(displayName)) {\n      // If the file name is 'index', better to get name from parent folder\n      displayName = basename(dirname(state.file.opts.filename));\n    }\n\n    // Remove the file extension\n    displayName = displayName.replace(/\\.[a-z0-9]+$/, '');\n\n    if (displayName) {\n      displayName += state.index;\n    } else {\n      throw path.buildCodeFrameError(\n        \"Couldn't determine a name for the component. Ensure that it's either:\\n\" +\n          '- Assigned to a variable\\n' +\n          '- Is an object property\\n' +\n          '- Is a prop in a JSX element\\n'\n      );\n    }\n  }\n\n  // Custom properties need to start with a letter, so we prefix the slug\n  // Also use append the index of the class to the filename for uniqueness in the file\n  slug =\n    slug ||\n    toValidCSSIdentifier(\n      `${displayName.charAt(0).toLowerCase()}${slugify(\n        `${relative(state.file.opts.root, state.file.opts.filename)}:${\n          state.index\n        }`\n      )}`\n    );\n\n  // Collect some useful replacement patterns from the filename\n  // Available variables for the square brackets used in `classNameSlug` options\n  const file = relative(process.cwd(), state.file.opts.filename).slice(1);\n  const ext = extname(file);\n  const slugVars: ClassNameSlugVars = {\n    hash: slug,\n    title: displayName,\n    file,\n    ext,\n    name: basename(file, ext),\n    dir: dirname(file).split(sep).pop() as string,\n  };\n\n  let className = predefinedClassName\n    ? predefinedClassName\n    : options.displayName\n    ? `${toValidCSSIdentifier(displayName!)}_${slug!}`\n    : slug!;\n\n  // The className can be defined by the user either as fn or a string\n  if (typeof options.classNameSlug === 'function') {\n    try {\n      className = toValidCSSIdentifier(\n        options.classNameSlug(slug, displayName, slugVars)\n      );\n    } catch {\n      throw new Error(`classNameSlug option must return a string`);\n    }\n  }\n\n  if (typeof options.classNameSlug === 'string') {\n    const { classNameSlug } = options;\n\n    // Variables that were used in the config for `classNameSlug`\n    const optionVariables = classNameSlug.match(/\\[.*?]/g) || [];\n    let cnSlug = classNameSlug;\n\n    for (let i = 0, l = optionVariables.length; i < l; i++) {\n      const v = optionVariables[i].slice(1, -1); // Remove the brackets around the variable name\n\n      // Replace the var if it key and value exist otherwise place an empty string\n      cnSlug = cnSlug.replace(\n        `[${v}]`,\n        isSlugVar(v, slugVars) ? slugVars[v] : ''\n      );\n    }\n\n    className = toValidCSSIdentifier(cnSlug);\n  }\n\n  const type =\n    templateType !== 'css' && templateType !== 'atomic-css'\n      ? 'styled'\n      : templateType;\n\n  debug(\n    `template-parse:generated-meta:${type}`,\n    `slug: ${slug}, displayName: ${displayName}, className: ${className}`\n  );\n\n  // Save evaluated slug and displayName for future usage in templateProcessor\n  path.addComment(\n    'leading',\n    `linaria ${type} ${slug} ${displayName} ${className}`\n  );\n}\n"],"file":"GenerateClassNames.js"}